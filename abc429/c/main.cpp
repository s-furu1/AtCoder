#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> A(N);
    int count = 0;
    for (int j = 0; j < N; j++) {
        cin >> A[j];
        for (int k = 1; k < N; k++) {
            if (k <= j) continue;
            cin >> A[k];
            for (int l = 2; l < N; l++) {
                if (k <= j) break;
                if (l <= k) continue;
                cin >> A[l];
                if ((A[j] == A[k] && A[j] != A[l]) || (A[j] == A[l] && A[j] != A[k]) || (A[k] == A[l] && A[j] != A[k])) {
                    count += 1;
                }
            }
        }
    }
    cout << count << endl;
}

// 長さNの整数列が与えれられ、Ai, Aj, Ak（0 < i < j < k <= N）を満たす整数の組みで、ちょうど2種類の値が含まれる物の個数を求める
// 3重ループを作成して、1,2,3が正解か判定→次は1,2,4...と判定していってカウントを出力する方向性。変数countは0で初期化。
// 結果が以下↓
// int main() {
//     int N;
//     cin >> N;
//     vector<int> A(N);
//     for (int i = 0; i < N; i++) {
//         cin >> A[i];
//     }
//     int count = 0;
//     for (int j = 0; j < N; j++) {
//         for (int k = 1; k < N; k++) {
//             if (k > j) {
//                 for (int l = 2; l < N; l++) {
//                     if (l > k) {
//                         if ((A[j] == A[k] && A[j] != A[l]) || (A[j] == A[l] && A[j] != A[k]) || (A[k] == A[l] && A[j] != A[k])) {
//                             count += 1;
//                         }
//                     }
//                 }
//             }
//         }
//     }
//     cout << count << endl;
// }
// そこまで計算量多くないと思ってたが考えが甘すぎてTLE。少し考える

// あとから2重ループで、その後のいずれか2つが等しくてもう1つは異なる条件を判定することができることがわかったが時すでに遅しコンテスト時間切れ。
// あとそもそもの考え方として、複数回出てくる数xを置いて、それを元に考えることができればO(N)で解くことができていたことも反省点。

// メモ 組み合わせを取得するには
// ある値xがn回登場していたとする。
// そこから同じ値を2つ選ぶ際の組み合わせとして
// n * (n - 1) / 2 = n回登場する値xを2つ選ぶ際の組み合わせ数
// となる。
// 残りの一つはその値以外のいずれでもOK。
// つまり全体の入力値から、xの総数を除いた
// [入力値の総数] - x = 残り1つのxとは異なる値
// となる
// これらを掛けることによって
// ([入力値の総数] - x) * (n * (n - 1) / 2) = 3つのうち等しい2つの数値xを元にした3組の整数列の組み合わせ数
// となる。